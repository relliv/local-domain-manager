import { NginxHelper } from './nginx-helper';
import { SettingsService } from '../../src/db/services/settings.service';
import { DomainService } from '../../src/db/services/domain.service';
import { ReverseProxyService } from '../../src/db/services/reverse-proxy.service';
import type { Domain } from '../../src/types/domain';
import type { ReverseProxyConfig } from '../../src/db/schema';

export class NginxConfigService {
  /**
   * Generate nginx server block for a domain
   */
  static generateServerBlock(domain: Domain, reverseProxy?: ReverseProxyConfig | null): string {
    const lines: string[] = ['server {'];
    
    // Listen directives
    lines.push(`    listen ${domain.port || 80};`);
    lines.push(`    listen [::]:${domain.port || 80};`);
    
    // Server name
    lines.push(`    server_name ${domain.name};`);
    
    // Access log
    lines.push('');
    lines.push(`    access_log /var/log/nginx/${domain.name}.access.log;`);
    lines.push(`    error_log /var/log/nginx/${domain.name}.error.log;`);
    
    // Root directory (for static sites)
    if (!reverseProxy || !reverseProxy.isActive) {
      lines.push('');
      lines.push(`    root /var/www/${domain.name};`);
      lines.push('    index index.html index.htm index.php;');
      lines.push('');
      lines.push('    location / {');
      lines.push('        try_files $uri $uri/ =404;');
      lines.push('    }');
    } else {
      // Add reverse proxy configuration
      lines.push('');
      lines.push(ReverseProxyService.generateLocationBlock(reverseProxy));
    }
    
    lines.push('}');
    
    return lines.join('\n');
  }

  /**
   * Create or update nginx config for a domain
   */
  static async createOrUpdateDomainConfig(domain: Domain): Promise<void> {
    const nginxPath = await SettingsService.getNginxPath();
    if (!nginxPath) {
      throw new Error('Nginx path not configured');
    }

    // Get reverse proxy config if exists
    const reverseProxy = await ReverseProxyService.getByDomainId(domain.id);
    
    // Generate server block
    const serverBlock = this.generateServerBlock(domain, reverseProxy);
    
    // Add header and footer
    const config = [
      '# Generated by Local Domain Manager',
      `# Domain: ${domain.name}`,
      `# Created: ${new Date().toISOString()}`,
      '',
      serverBlock,
      ''
    ].join('\n');
    
    // Write config file
    await NginxHelper.writeNginxConfig(nginxPath, domain.name, config);
    
    // Test nginx configuration
    const testResult = await NginxHelper.testNginxConfig();
    if (!testResult.valid) {
      // Remove the invalid config
      try {
        await this.removeDomainConfig(domain.name);
      } catch {
        // Ignore removal errors
      }
      throw new Error(`Invalid nginx configuration: ${testResult.error}`);
    }
    
    // Reload nginx if auto-reload is enabled
    const autoReload = await SettingsService.getSetting('auto_reload_nginx');
    if (autoReload === 'true') {
      await NginxHelper.reloadNginx();
    }
  }

  /**
   * Remove nginx config for a domain
   */
  static async removeDomainConfig(domainName: string): Promise<void> {
    const nginxPath = await SettingsService.getNginxPath();
    if (!nginxPath) {
      throw new Error('Nginx path not configured');
    }

    const configPath = NginxHelper.getDomainConfigPath(nginxPath, domainName);
    
    try {
      const fs = require('fs/promises');
      await fs.unlink(configPath);
      
      // Reload nginx if auto-reload is enabled
      const autoReload = await SettingsService.getSetting('auto_reload_nginx');
      if (autoReload === 'true') {
        await NginxHelper.reloadNginx();
      }
    } catch (error: any) {
      if (error.code !== 'ENOENT') {
        throw error;
      }
      // File doesn't exist, that's okay
    }
  }

  /**
   * Check if domain needs nginx config
   */
  static async shouldCreateNginxConfig(domain: Domain): Promise<boolean> {
    // Only create nginx config for root domains (not subdomains)
    // unless specifically configured otherwise
    return !domain.parent_id;
  }

  /**
   * Sync all domains with nginx
   */
  static async syncAllDomains(): Promise<{
    created: string[];
    updated: string[];
    removed: string[];
    errors: Array<{ domain: string; error: string }>;
  }> {
    const result = {
      created: [] as string[],
      updated: [] as string[],
      removed: [] as string[],
      errors: [] as Array<{ domain: string; error: string }>
    };

    const nginxPath = await SettingsService.getNginxPath();
    if (!nginxPath) {
      throw new Error('Nginx path not configured');
    }

    // Get all active root domains
    const domains = await DomainService.getAllDomains();
    const rootDomains = domains.filter(d => d.is_active && !d.parent_id);

    for (const domain of rootDomains) {
      try {
        const exists = await NginxHelper.configExists(nginxPath, domain.name);
        
        if (exists) {
          await this.createOrUpdateDomainConfig(domain);
          result.updated.push(domain.name);
        } else {
          await this.createOrUpdateDomainConfig(domain);
          result.created.push(domain.name);
        }
      } catch (error: any) {
        result.errors.push({
          domain: domain.name,
          error: error.message
        });
      }
    }

    return result;
  }
}